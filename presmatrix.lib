///////////////////////////////////////////////////////////////////////////////
version="$Id: presmatrix.lib  2013-12-03 $";
category="Singularity Theory, Commutative Algebra";
info="
LIBRARY:  presmatrix.lib          Compute presentation matrix

AUTHORS:  Marcelo Escudeiro Hernandes,     mehernandes@uem.br
          Aldicio Jose Miranda,            aldicio@famat.ufu.br
          C. Munoz-Cabello,                chmuca@alumni.uv.es
          Guillermo Penafort-Sanchis,      guillermo.penafort@uv.es
  
PROCEDURES:
  multipoints(f);				multiple point spaces
  presmatrix(Pullf, ISource); 	presentation matrix
  
 
AUXILIARY PROCEDURES:
  Sols(nJ);          return solutions of linear system of parameters
  Row(rh,D,A,h);     compute rh^th line of the presentation matrix
  PolyCoefOne(d);        create polynomial with coefs = 1 and degree d
 ";

 LIB "matrix.lib";   // diag
 LIB "rootsur.lib";
 LIB "ring.lib";
 LIB "homolog.lib";

//-----------------------------------------------------------------------------
proc multipoints (map f, ideal i, list #)
{
    ring source = basering;

    presmatrix(f, i);

	if (size(#) > 0) { return (fitting(@PM, #[1])); }

    vector F[nvars(source)+1];
	
    for (int j = 1; j <= nvars(source) + 1; j++)
    { F[j] = fitting(@PM, j-1); }

    return (F);
}

//-----------------------------------------------------------------------------
proc presmatrix(map f, ideal i)
{
    /* Let f: X,x -> C[n+1] be a finite map germ with X,x Cohen-Macaulay and
    /* I be the ideal generated by the generating function of X.
    /* The following is a summary of the algorithm described in [1],
    /* section 11.1:
    /*
	/* 1. Choose a projection p: C[n+1] -> Cn such that pf=p*f is finite.
	/* We shall assume coordinates in the target st p[x1..x[n+1]]=[x1..xn]
	/*
	/* 2. Let OX be the space of holomorphic functions on X.
	/* There exists a C-basis 1,g1..gm for OX/pif^*m.
	/* 
	/* 3. There is a unique matrix L such that
	/*
	/*    [  f[n+1] ]     [ 1 ]
	/*    [g1*f[n+1]]     [ g1]
	/*    [   ...   ] = L [...]
	/*    [gm*f[n+1]]     [ gm]
	/*
	/* 4. The sought presentation matrix is L - diag(f[n+1]). */

	// Step 1: Find a suitable representation of f

	option(noredefine);
    
    if (ord_test(basering) != -1)
    {
        print("// " + nameof(basering) + " is not local!");
        "// Get generators using local order (ds)";

        ERROR("no local order ring");
    }

    ideal fm = ideal(f);			// f^*m
    ring source = basering;			
    ring target = preimage(f);

    if (nvars(target) != nvars(source) + 1)
    { ERROR(nameof(f) + " not a parametric hypersurface"); }

    if (nvars(target) != size(fm))
    {
		print("// Dimension of ring " + nameof(target) + " does not match the number of");
    	print("// components in " + nameof(f) + " !");
        ERROR("dimension mismatch");
    }

	setring source;

	// the first n components will give a finite map
    map pf = FiniteProjection(fm, nameof(f));

    // find generators for Q(f) (they will be exported)
	LocalAlgBasis(pf, i, nameof(f));

	// compute the presentation matrix
}

//-----------------------------------------------------------------------------
static proc FiniteProjection (ideal f, string fname)
{
	/* A map f: Kn -> K[n+1] is finite if and only if On/f^*m has finite
	/* dimension.
	/* Finiteness of f implies that we can find a projection p: C[n+1]->Cn such
	/* that pf = p*f is finite. */

	if (vdim(f) == -1) { ERROR(fname + " is not finite"); }

	for (int i = 1; i <= size(f); i++)
	{
	    intvec k = delete(1..size(f), i);
        ideal pf = std(f[k]);                // GrÃ¶bner basis
	
	    if (vdim(pf) != -1)
	    {
	        // append the stray component at the end
	        
	        pf = pf + f[i];
	        return (pf);
	    }
	}
}

//-----------------------------------------------------------------------------
static proc LocalAlgBasis (ideal f, i, string fname)
{
    // compute the local algebra of f: X -> C[n+1] where X = V(i)
	ideal fi = f, i;
	ideal Q = kbase(std(fi));

	if (size(Q) == 0)
	{
		print("// Quotient algebra Q(" + fname + ") has no generators!");
		"// Please verify input";

		ERROR("invalid map " + namef);
	}

	// change the order of the generators
	matrix @generators[1][size(Q)];

    for (int j = 1; j <? size(Q); j++)
	{ @generators[1, j] = Q[size(Q) + 1 - j]; }

	"// Generators of Q(" + fname + "):";
	print(@generators);
	"";

	export(@generators);
	"// Access these generators on global scope as @generators";
}

//-----------------------------------------------------------------------------
static proc ???(ideal f, i)
{
	ring source = basering;
	ring target = preimage(f);

	setring source;
	int dimQ = size(@generators);

	setring target;
    matrix M[dimQ][dimQ];
    matrix Pres = diag(Y, dimQ);

    ring RS = 0, (x(1..l)), ds;	                    //internal auxiliary ring source
    ideal IPf = fetch(source, f);
    ideal I = fetch(source, i);
 							
    int done;
    for(int rh = 1; rh <= h; rh++)
 	{
        int d = 1;
        
 		while(!done)
 		{
 		    setring target;
 		    
 		    // define a polynomial of degree d with coefficients set to 1
 			poly D, A = PolyCoefOne(d, nvars(target));

 			// define an extended target ring with parameters
            int np = size(D) + (size(@generators) - 1) * size(A) - 1;
            ring target_param = (0,a(1..np)), (X(1..n),Y), ds;
			poly D = fetch(target, D);
			poly A = fetch(target, A);
			
			list    ML=Row(rh,D,A,h);                           //see proc Row below
			matrix  M=ML[1];
			list    ParList=ML[2];
			map     mM=RG,M;                                    //mM[i]=M[1,i], i=num.generators
		    ring    RSP1=(0,a(1..np)),x(1..l),dp;               //source ring with the same parameters
			ideal   IPf=fetch(RS,IPf);                          //copying IPf from Rs to RSP1
	    	map     Pf=RTP1,IPf;     
			ideal   I=fetch(RS,I);  I=std(I); 
	        matrix generators = fetch(source, @generators);
  						
			poly p=(Pf(mM)[1])*Gen[1,1];
    			for(int c=2;c<=h;c++)
			{
				p=p+Pf(mM)[c]*Gen[1,c];
			}  //we multiply the row matrix M by column matrix Gen, getting the generic polynomial
			   //in the source. Next step is to reduce modulo ideal I.
      			p=reduce(p,I);

			ideal J; 
			poly u=1;
			for(int v=1;v<=l;v++)
			{
				u=x(v)*u;  //its need to use "coef" below
			}		
			matrix C=coef(p,u);
		      	J=ideal(submat(C,2,1..ncols( C)));
			int sj=size(J); int i=1; int k;
				ring RP=0,(a(1..np)),dp; //ring of parameters
				ideal J=imap(RSP1,J);
			       	list  L=Sols(J); 
				if(L[1]==0)
				{
					// if the linear system of param. has no solution, then the degree increases
					 d++;
				}
				
				else      
				{
					done = 1;
					setring RT;          //go to target ring RT: (X[1],...X],Y)
					list    L=imap(RP,L);   
					list    ParList=imap(RTP1,ParList);
					int     szS=size(L[2]);
					int      pr;
					for(int i=1;i<=szS;i++)
					{
						pr=L[2][i][1];
						Pres[rh,ParList[pr][2]]=Pres[rh,ParList[pr][2]]+L[2][i][2]*ParList[pr][1];
					}//here just replace the parameters by respective solutions
				}
		    }
    	}
    	
	ring RTPr = 0, (nvars(target)),ds";
    matrix PM[h][h]=fetch(RT,Pres);
	exportto(Top,RTPr);
    exportto(Top,PM);





	string Rh = nameof(target) + "^" + string(h);
   	
   	print("//" + Rh + " --> " + Rh + " --> Ox --> 0");
   	"";
   	"// Presentation matrix:";
   	print(@PM);

	export(@PM);
   	"// Type @PM to access the presentation matrix from global scope.";
}

//---------------------------------------proc Sols return solutions of linear system of parameters-----------

static proc Sols(ideal J)
{ 
    list L;
    J = std(J);

    if(reduce(1, J) == 0)
	{
	    L[1]=0;
	    L[2]=list();
	}
	else
	{
        L[1]=1; 
        L[2]=list();
        poly LM, Su, Ji;
        number LC;
        int s=size(J);
        int pos=1;
        int i=1;
        
        while(L[1] == 1 && i <= s)
	    {	
			LC=leadcoef(Ji); 	
			if(leadcoef(J[i]) != 0)
			{	LM=leadmonom(leadcoef(J[i]));
				Su = -J[i] / leadcoef(J[i]) + leadmonom( leadcoef(J[i]) );
				
				for(int j=i+1; j<=s; j++)
				{ J[j] = subst(J[j], leadmonom(leadcoef(J[i])), Su); }
			}
			
		  	i++;
		}
		
		for(int i=s; i>=1; i--)
		{
		    if (J[i] != 0)
			{
			    while( !univariate(J[i]) )
                { J = subst(J, leadmonom(J[i]), 0); }

				LM = leadmonom(J);
				Su = -J[i] / leadcoef(J[i]) + leadmonom(J[i]);
              	L[2][pos] = list(univariate(J[i]), Su);

 				pos++;
				J = subst(J, leadmonom(J), Su);
			}
		}
    }
    
     return(L);
}
	     
//--------------------------------------------------------------------------------------------------

static proc Row(int rh,poly D,poly A, int h)
// rh = rh line; D = diagonal polin; A= no diagonal polin.; h = order of present. matrix;
{
  matrix M[1][h];
  D=D-Y; 	 
  int sD=size(D);
  int sA=size(A); 
  list ParList;
  int c=1;
     for(int j=1;j<rh;j++) //before(or left) the diagonal 
        {   
	  for(int i=1;i<=sA;i++)
	    {                
		  M[1,j]=A[i]*par( c)+M[1,j];//par(m)=m^th param. of basering
		  ParList[c]=list(A[i],j);
		  c++;
   	    }
	} 

     for(int i=1;i<=sD;i++)   //in the diagonal
       {
  	 M[1,rh]=D[i]*par( c)+M[1,rh];
  	 ParList[c]=list(D[i],rh);
  	 c++;
       } 

     M[1,rh]=M[1,rh]+Y; //then the coef.of Y is "1"  

    for(int j=rh+1;j<=h;j++) //after (or right) the diagonal
      {
	 for(int i=1;i<=sA;i++)
	   {
	        M[1,j]=A[i]*par( c)+M[1,j];
	        ParList[c]=list(A[i],j);
	        c++;
	   }
      }
  list L;
  L[1]=M;L[2]=ParList;
  return(L);
}

//-----------------------------------------------------------------------------
static proc PolyCoefOne(int d, poly x)
{
	// Create a degree d poylnomial over the variable x
	// and coefficients set to 1

    poly D = sparsepoly(0, d, 0, 1);
    poly PY;

	for(int i = 1; i <= d; i++) { PY = PY + x^i; }

    return (D, D - PY);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
