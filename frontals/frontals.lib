///////////////////////////////////////////////////////////////////////////////
version="$Id: frontalsurf.lib  2022-17-03 $";
category="Singularities";
info="
LIBRARY: frontals.lib       Geometric invariants of a corank 1 frontal
                            hypersurface

AUTHORS: C. Munoz-Cabello,  christian.munoz@uv.es

PROCEDURES:
    fcodim(f[, F, d]);   frontal codimension
    invariants(f);       geometric frontal invariants
    wfinvariants(g, z);  geometric invariants of the discriminant

REFERENCES:
    [GLS] Greuel, G.-M.; Lossen, C.; Shustin, E.
        Introduction to singularities and deformations (2007)
    [Ish] Ishikawa, G.
        Recognition problem of frontal singularities (2020)
    [MMR] Marar, W.L.; Montaldi, J.A.; Ruas, M.A.S.;
        Multiplicities of zero-schemes in quasihomogeneous corank-1
        singularities (1999)
    [MNB] Mond, D.; Nuno-Ballesteros, J.J.
        Singularities of Mappings (2020)
    [MNO1] Munoz-Cabello, C.; Nuno-Ballesteros, J.J.; Oset Sinha, R.
        Deformations of Corank 1 Frontals (TBP)
    [MNO2] Munoz-Cabello, C.; Nuno-Ballesteros, J.J.; Oset Sinha, R.
        Singularities of Frontal Surfaces (TBP)
";

LIB "general.lib";      // product
LIB "hnoether.lib";     // delta invariant
LIB "homolog.lib";		// fitting
LIB "presmatrix.lib";   // presmatrix
LIB "ring.lib";         // ord_test
LIB "sing.lib";         // tjurina

//-----------------------------------------------------------------------------
proc fcodim(list #)
"USAGE:   fcodim(f[, G, d]);  f = poly or ideal; F = poly; d = int

RETURN:   frontal codimension of an integral corank 1 frontal hypersurface f
          with d-parameter stable frontal deformation F
          
REMARK: * Deformation parameters must be added at the end in ring declaration
        * Plane curves do not require a deformation to be declared
        * This version of fcodim is only beta. Please send bugs and
          comments to: <https://github.com/cuspidalcoffee/Singular>
          Known to work on Singular version 4.2.0.
          
EXAMPLE:  example fcodim; shows an example"
{
    baseringlocal();

    if (nvars(basering) == 1)
    {
        "// ** plane curves must be given in implicit form";
        
    }

    if (nvars(basering) == 2)
    	{ return(tjurina(f) - delta(f) - mult(f) + 1); }

    if (nvars(basering) > 2)
    {
        if (size(#) == 0)
            { ERROR("stable unfolding not provided"); }
        if (size(#) == 1)
            { ERROR("number of deformation parameters not provided"); }
    }
   
    poly F = #[1];
    int d = #[2];

    /* computations */

    ideal JF = jacob(F), F;
    ideal JrelF = JF[1..nvars(basering) - d], f;

    // compute the quotient and specialise
	module MF = modulo(JF, JrelF);

	for (int i = 0; i < d; i++)
        { MF = subst(MF, var(nvars(basering) - i), 0); }

    ring paramring = basering;
    ring noparamring = char(paramring), x(1..nvars(paramring) - d), ds;
    module MF = fetch(paramring, MF);

    return(vdim(std(MF)));
}
example
{
    "EXAMPLE";
    echo = 2;

    // E_8 singularity from Bruce and Gaffney (1982)
    ring source = 0, (x, y), ds;
    poly f = x5 + y3;
    fcodim(f);

    // D_4 singularity from Arnol'd (1990)
    ring source = 0, (x,y,t,X,Y,Z,T), ds;

    ideal i = xy-X, x2+3y2-Y, y3+x2y-Z;
    ideal I = xy-X, x2+3y2+2yt-Y, y3+x2y+1/2y2t-Z, t-T;

    poly f = eliminate(i, xy)[1];
    poly F = eliminate(I, xyt)[1];

    ring source_noparams = 0, (X,Y,Z,T), ds;
    poly f = imap(source, f);
    poly F = imap(source, F);

    fcodim(f, F, 1);
}

//-----------------------------------------------------------------------------
proc invariants(map f)
"USAGE:   invariants(f);  f = map

COMPUTE:  isolated singularities and frontal Milnor number of a corank 1
          frontal surface

RETURN:   * number of swallowtails, cuspidal double points, triple points and
            folded Whitney umbrellas in the disentanglement of f
          * cuspidal edge (@cuspedge) and double point (@dpoints) curves,
            along with their Milnor numbers
          * frontal Milnor number
          
REMARK:   This version of invariants is only beta. Please send bugs and
          comments to: <https://github.com/cuspidalcoffee/Singular>
          Known to work on Singular version 4.2.0.
          
NOTE:     objects with @ sign are exported to global scope

EXAMPLE:  example invariants; shows an example"
{
    string br_name = nameof(basering);  // we need this for presmatrix
    baseringlocal();
    checkvars(2);
    option(noredefine);                 // hide messages such as "redefining"

    int S, K, W, C, D = dpscheme(c1coordinates(f));
    
    // image triple point space
    ideal @I = 0;
    export(@I);                         // we need this for presmatrix
    
    "";
    "// Computing triple point space...";
    presmatrix(f, @I);
    setring RTPr;
    int T = vdim(std(fitting(PM, 2))) - S - K;
    
    execute("setring " + string(br_name));
    int mufC = 2 * S + muC;
    number mufD = K + T + 1/2 * (muD + 1 - W - S);
    number muf = mufD + T + 1 - S - W;
    
    "";
    "Isolated frontal singularities:";
    " * Swallowtails:              " + string(S);
    " * Cusp-folds:                " + string(K);
    " * Triple points:             " + string(T);
    " * Folded Whitney umbrellas:  " + string(W);
    
    "";
    "Branch of cuspidal edges:";
    " * @cuspedge = " + string(@cuspedge);
    " * Milnor number (source):   " + string(muC);
    " *               (target):   " + string(mufC);
    "";
    
    "Branch of transversal double points:";
    " * @dpoints = " + string(@dpoints);
    " * Milnor number (source):   " + string(muD);
    " *               (target):   " + string(mufD);
    "";
    
    "Frontal Milnor number:       " + string(muf);
    "";
}
example
{
    "EXAMPLE";
    echo = 2;

    ring target = 0, (x, y, z), ds;
    ring source = 0, (x, y), ds;
    export(source, target);  // only needed for this example!

    // 5_3 singularity from Marar and Tari (1995)
    map f = target, x, 5y4 + 3xy2, 4y5 + 2xy3;
    invariants(f);
}

//-----------------------------------------------------------------------------
proc wfinvariants(poly g, poly z)
"USAGE:   wfinvariants(g, z);  g, z = poly

COMPUTE:  invariants in the discriminant of the mapping 

              G(x, y, z) = (x, y, g(x, y, z))

          using the formulas from W.L. Marar, J.A. Montaldi and M.A.S. Ruas's
          "\Multiplicities of zero-schemes in quasihomogeneous corank-1
          singularities"\
          
RETURN:   number of swallowtails, cuspidal double points and triple points in
          the discriminant of G.
          
REMARK:   * g must be weighted homogeneous
          * This version of wfinvariants is only beta. Please send bugs and
          comments to: <https://github.com/cuspidalcoffee/Singular>
          Known to work on Singular version 4.2.0.

EXAMPLE:  example wfinvariants; shows an example"
{
    baseringlocal();
    checkvars(3);
    option(noredefine);     // hide messages such as "redefining"

    /* compute the weights and the weighted degree of g */
    
    intvec w = qhweight(g);

    if (w == 0)
    {
        "// ** this procedure only works for weighted homogeneous polynomials";
        ERROR(nameof(g) + "not weighted homogeneous");
    }

    poly homogenised_g;

    for (int i = 1; i <= size(w); i++)
        { homogenised_g = subst(g, var(i), var(i)^w[i]); }

    int d = deg(homogenised_g);

    /* Apply the formulas by Marar, Montaldi and Ruas.
     * We could do this in general if we had a partition function implemented;
     * fortunately, there is one in Oscar! */

    if(rvar(z) == 0) { ERROR("variable " + nameof(z) " not in base ring"); }

    int declared_var = rvar(z);

    intvec prod_vector = d div w[declared_var] * (1, 1, 1) - (1, 2, 3);

    /* Singular does not like to use the `/` sign for integer division, so we
     * need to use `div` instead */

    int S = w[declared_var]^3 * product(prod_vector) div product(w);
    int K = S * (d - 4 * w[declared_var]) div w[declared_var];
    int T = K * (d - 5 * w[declared_var]) div (6 * w[declared_var]);

    "";
    " * Swallowtails:                 " + string(S);
    " * Cuspidal double points:       " + string(K);
    " * Triple points:                " + string(T);
    "";
    " * Target triple point space:    " + string(S + K + T);
    "";
}
example
{
    "EXAMPLE";
    echo = 2;

    ring r = 0, (x, y, z), ds;

    // 5_3 singularity from Marar and Tari (1995)
    wfinvariants(z5 + xz + yz3, z);
}

//-----------------------------------------------------------------------------
static proc baseringlocal()
{
    option(noredefine);  // hide messages such as "redefining"

    if (ord_test(basering) != -1) { ERROR("no local order ring"); }
}

//-----------------------------------------------------------------------------
static proc checkvars(int n)
{
    option(noredefine);  // hide messages such as "redefining"

    if (nvars(basering) != n)
    {
        ERROR("ring " + nameof(basering) + " must have " + string(n) +
        " variables");
    }
}

//-----------------------------------------------------------------------------
static proc c1coordinates (map f)
{
    /* "Non-free variable" refers to the variable x such that the partial
     * derivative of f with respect to x vanishes at 0.
     * If we write
     *     f[x, y] = [x, p[x,y], q[x, y]],
     * the non-free variable is y. */

    int free;

	for (i=1; i <= 3; i++)
	{
	    for (j=1; j <= 2; j++)
	    {
	        if( diff(f[i], var[j]) == 1 )
	        {
	            free = j;
	            int freevar_pos = i;
	        }
	    }
	}

	/* the free variable has index j and is placed in the i position of f */

	if (free == 0)
	{
		"// ** please introduce " + nameof(f) + " as a map in the form";
		"// **         var, p, q";
		"// ** for p, q = poly and var a ring variable";

		ERROR("invalid input format");
	}

    /* Checking for frontality */

    int nonfree = j % 2 + 1;
    poly py = diff( f[i % 3 + 1], var[nonfree] );
    poly qy = diff( f[(i % 3 + 1) % 3 + 1], var[nonfree] );

	// Return the free variable, the positions for p and q, and qy/py

    if (qy % py == 0)
        { return(var[nonfree], f[i % 3 + 1], f[(i % 3 + 1) % 3 + 1]); }
    if (py % qy == 0)
    	{ return(var[nonfree], f[(i % 3 + 1) % 3 + 1], f[i % 3 + 1]); }

    ERROR("input not frontal");
}

//-----------------------------------------------------------------------------
static proc dpscheme(poly p, poly q, poly y)
{
    /* define a ring of divided differences by adding an auxiliary variable */
    
    ring source = basering;
    ring auxiliary = char(source), @z, ds;
    def ddring = source + auxiliary;
    setring ddring;

    poly p = imap(source, p);
    poly q = imap(source, q);
    poly y = imap(source, y);

    "// Computing double point scheme...";
    poly P = (p - subst(p, y, @z)) / (y - @z);
    poly Q = (q - subst(q, y, @z)) / (y - @z);
    poly py = diff(p, y);
    poly tau = resultant(P, Q, @z) / py^2;

    poly alpha = reduce(P, py) / (y - @z);    // 2S + K
    poly beta = reduce(Q, py) / (y - @z);
    ideal PAA = py, alpha, beta;
    int dimPAA = vdim(std(PAA));
 
    setring src;
    poly @cuspedge = imap(divdifring, py);    // S
    ideal P3 = @cuspedge, diff(@cuspedge, y);
    int dimP3 = vdim(std(P3));
 
    poly @dpoints = imap(divdifring, tau);    // 2S + K + W
    ideal PT = @cuspedge, @dpoints;
    int dimPT = vdim(std(PT));

    export(@cuspedge, @dpoints);
    return(dimP3,                             // S
           dimPAA - 2 * dimP3,                // K
           dimPT - dimPAA,                    // W
           milnor(@cuspedge),                 // C
           milnor(@dpoints));                 // D
}
