///////////////////////////////////////////////////////////////////////////////
version="$Id: frontals.lib  2023-06-20 $";
category="Singularities";
info="
LIBRARY: frontals.lib       Compute geometric invariants of a corank 1 frontal
                            surface

AUTHORS: C. Munoz-Cabello,  christian.munoz@uv.es

PROCEDURES:
    fcodim(f);           frontal codimension of a plane curve
    invariants(f);       geometric frontal invariants
    wfinvariants(g, z);  geometric invariants of the discriminant

REFERENCES:
    [GLS] Greuel, G.-M.; Lossen, C.; Shustin, E. (2007) Introduction to
       singularities and deformations
    [Ish] Ishikawa, G.
        Recognition problem of frontal singularities (2020)
    [MMR] Marar, W.L.; Montaldi, J.A.; Ruas, M.A.S.;
        Multiplicities of zero-schemes in quasihomogeneous corank-1
        singularities (1999)
    [MNB] Mond, D.; Nuno-Ballesteros, J.J.
        Singularities of Mappings (2020)
    [MNO] Munoz-Cabello, C.; Nuno-Ballesteros, J.J.; Oset Sinha, R.
        Singularities of Frontal Surfaces (2024)
";

LIB "general.lib";      // product
LIB "hnoether.lib";     // delta invariant
LIB "homolog.lib";		// fitting
LIB "presmatrix.lib";   // presmatrix
LIB "ring.lib";         // ord_test
LIB "sing.lib";         // tjurina

//-----------------------------------------------------------------------------
proc fcodim(poly f, list #)
"USAGE:   fcodim(f[, F, d]);  f, F = poly; d = int

RETURN:   frontal codimension of a frontal hypersurface given by the ideal f,
          with stable frontal unfolding in n parameters given by the ideal F
          (not required for plane curves!)
          
REMARK:   * Unfolding variables must be added at the end in ring declaration
          * This version of fcodim is only beta. Please send bugs and
          comments to: <https://github.com/cuspidalcoffee/Singular>
          Known to work on Singular version 4.2.0.
          
EXAMPLE:  example fcodim; shows an example"
{
    baseringlocal();

    // we need to shed the parameter variables later
    ring paramring = basering;

    if (nvars(basering) > 1 && size(#) == 0)
        { ERROR("stable unfolding not provided"); }

    // since # is a polymorphism, we need to check typing

	if (typeof(#[1]) != "poly")
	    { ERROR(nameof(#[1]) + " not a polynomial"); }

    poly F = #[1];

	if (typeof(#[2]) != "int")
	    { ERROR("number of unfolding parameters not specificed"); }

    int d = #[2];

    /* computations */

    if (nvars(basering) == 1)
    	{ return(tjurina(f) - delta(f) - mult(f) + 1); }

    "// ** The formula that is about to be applied is based on a conjecture by";
    "// ** Nuno-Ballesteros, and may be inaccurate.";

    ideal JF = jacob(F), F;
    ideal JrelF = JF[1..nvars(basering) - d], f;

    // compute the quotient and tensorize
	module MF = modulo(JF, JrelF);

	for (int i = nvars(basering) + d; i > nvars(basering); i--)
        { MF = subst(MF, var(i), 0); }

    ring noparamring = char(paramring), x(1..nvars(paramring) - d), ds;
    module MF = imap(paramring, MF);

    return vdim(std(MF));
}
example
{
    "EXAMPLE";
    echo = 2;

    ring source = 0, (x, y, t), ds;
    
    // E_8 singularity from Bruce and Gaffney (1982)
    poly f = x5 + y3;
	ideal g = elim(f,xy);
    
    fcodim(g);
}

//-----------------------------------------------------------------------------
proc invariants(map f)
"USAGE:   invariants(f);  f = map

COMPUTE:  isolated singularities and frontal Milnor number of a corank 1
          frontal surface

RETURN:   * number of swallowtails, cuspidal double points, triple points and
            folded Whitney umbrellas in the disentanglement of f
          * cuspidal edge (@cuspedge) and double point (@dpoints) curves,
            along with their Milnor numbers
          * frontal Milnor number
          
REMARK:   This version of invariants is only beta. Please send bugs and
          comments to: <https://github.com/cuspidalcoffee/Singular>
          Known to work on Singular version 4.2.0.
          
NOTE:     objects with @ sign are exported to global scope

EXAMPLE:  example invariants; shows an example"
{
    string br_name = nameof(basering);  // we need this for presmatrix
    baseringlocal();
    checkvars(2);
    option(noredefine);                 // hide messages such as "redefining"
    
    int S, K, W, C, D = dpscheme(c1coordinates(f));

    // image triple point space
    ideal @I = 0;
    export(@I);                         // we need this for presmatrix

    "";
    "// Computing triple point space...";
    presmatrix(f, @I);
    setring RTPr;
    int T = vdim(std(fitting(PM, 2))) - S - K;

    execute("setring " + string(br_name));
    int mufC = 2 * S + muC;
    number mufD = K + T + 1/2 * (muD + 1 - W - S);
    number muf = mufD + T + 1 - S - W;

    "";
    "Isolated frontal singularities:";
    " * Swallowtails:              " + string(S);
    " * Cusp-folds:                " + string(K);
    " * Triple points:             " + string(T);
    " * Folded Whitney umbrellas:  " + string(W);

    "";
    "Branch of cuspidal edges:";
    " * @cuspedge = " + string(@cuspedge);
    " * Milnor number (source):   " + string(muC);
    " *               (target):   " + string(mufC);
    "";

    "Branch of transversal double points:";
    " * @dpoints = " + string(@dpoints);
    " * Milnor number (source):   " + string(muD);
    " *               (target):   " + string(mufD);
    "";

    "Frontal Milnor number:       " + string(muf);
    "";
}
example
{
    "EXAMPLE";
    echo = 2;

    ring target = 0, (x, y, z), ds;
    ring source = 0, (x, y), ds;
    export(source, target);  // only needed for this example!

    // 5_3 singularity from Marar and Tari (1995)
    map f = target, x, 5y4 + 3xy2, 4y5 + 2xy3;
    invariants(f);
}

//-----------------------------------------------------------------------------
proc wfinvariants(poly g, poly z)
"USAGE:   wfinvariants(g, z);
              g, z = poly

COMPUTE:  invariants in the discriminant of the mapping 

                  G(x, y, z) = (x, y, g(x, y, z)),
              
          using the formulas from W.L. Marar, J.A. Montaldi and M.A.S. Ruas's
          "\Multiplicities of zero-schemes in quasihomogeneous corank-1
          singularities"\
          
RETURN:   number of swallowtails (@S), cusp-folds (@K) and triple points (@T)
          in the discriminant of G.
          
REMARK:   * g must be weighted homogeneous
          * This version of wfinvariants is only beta. Please send bugs and
          comments to: <https://github.com/cuspidalcoffee/Singular>
          Known to work on Singular version 4.2.0.
          
NOTE:     objects with @ sign are exported to global scope

EXAMPLE:  example wfinvariants; shows an example"
{
    baseringlocal();
    checkvars(3);
    option(noredefine);     // hide messages such as "redefining"

    /* compute the weights and the weighted degree of g */
    
    intvec weights = qhweight(g);

    if (w == 0)
    {
        "// ** this procedure only works for weighted homogeneous polynomials";
        ERROR(nameof(g) + "not weighted homogeneous");
    }

    poly homogenised_g;
    
    for (int i = 1; i <= size(w); i++)
        { homogenised_g = subst(g, var(i), var(i)^w[i]); }

    int d = deg(homogenised_g);

    /* Apply the formulas by Marar, Montaldi and Ruas.
     * We could do this in general if we had a partition function implemented;
     * fortunately, there is one in Oscar! */

    if(rvar(z) == 0) { ERROR("variable " + nameof(z) " not in base ring"); }

    int declared_var = rvar(z);

    intvec prod_vector = w[4] div w[declared_var] * (1, 1, 1) - (1, 2, 3);

    /* Singular does not like to use the `/` sign for integer division, so we
     * need to use `div` instead
     * (https://www.singular.uni-kl.de/Manual/4-0-3/sing_466.htm) */

    int @S = w[declared_var]^3 * product(prod_vector) div product(w, 1..3);
    int @K = @S * (w[4] - 4 * w[declared_var]) div w[declared_var];
    int @T = @K * (w[4] - 5 * w[declared_var]) div (6 * w[declared_var]);

    "";
    " * Swallowtails:               @S = " + string(@S);
    " * Cusp-folds:                 @K = " + string(@K);
    " * Triple points:              @T = " + string(@T);
    "";
    " * Target triple point space:       " + string(@S + @K + @T);
    "";
    export(@S, @K, @T);
}
example
{
    "EXAMPLE";
    echo = 2;

    ring r = 0, (x, y, z), ds;

    // 5_3 singularity from Marar and Tari (1995)
    wfinvariants(z5 + xz + yz3, z);
}

//-----------------------------------------------------------------------------
static proc baseringlocal()
{
    option(noredefine);  // hide messages such as "redefining"

    if (ord_test(basering) != -1) { ERROR("no local order ring"); }
}

//-----------------------------------------------------------------------------
static proc checkvars(int n)
{
    option(noredefine);  // hide messages such as "redefining"

    if (nvars(basering) != n)
    {
        ERROR("ring " + nameof(basering) + " must have " + string(n) +
        " variables");
    }
}

//-----------------------------------------------------------------------------
static proc c1coordinates (map f)
{
    /* "Non-free variable" refers to the variable x such that the partial
     * derivative of f with respect to x vanishes at 0.
     * If we write
     *     f[x, y] = [x, p[x,y], q[x, y]],
     * the non-free variable is y. */

    int free;

	for (i=1; i <= 3; i++)
	{
	    for (j=1; j <= 2; j++)
	    {
	        if( diff(f[i], var[j]) == 1 )
	        {
	            free = j;
	            int freevar_pos = i;
	        }
	    }
	}

	/* the free variable has index j and is placed in the i position of f */

	if (free == 0)
	{
		"// ** please introduce " + nameof(f) + " as a map in the form";
		"// **         var, p, q";
		"// ** for p, q = poly and var a ring variable";

		ERROR("invalid input format");
	}

    /* Checking for frontality */

    int nonfree = j % 2 + 1;
    poly py = diff( f[i % 3 + 1], var[nonfree] );
    poly qy = diff( f[(i % 3 + 1) % 3 + 1], var[nonfree] );

	// Return the free variable, the positions for p and q, and qy/py

    if (qy % py == 0)
        { return(var[nonfree], f[i % 3 + 1], f[(i % 3 + 1) % 3 + 1]); }
    if (py % qy == 0)
    	{ return(var[nonfree], f[(i % 3 + 1) % 3 + 1], f[i % 3 + 1]); }

    ERROR("input not frontal");
}

//-----------------------------------------------------------------------------
static proc dpscheme(poly p, poly q, poly y)
{
    /* define a ring of divided differences by adding an auxiliary variable */
    
    ring source = basering;
    ring auxiliary = char(source), @z, ds;
    def ddring = source + auxiliary;
    setring ddring;

    poly p = imap(source, p);
    poly q = imap(source, q);
    poly y = imap(source, y);

    "// Computing double point scheme...";
    poly P = (p - subst(p, y, @z)) / (y - @z);
    poly Q = (q - subst(q, y, @z)) / (y - @z);
    poly py = diff(p, y);
    poly tau = resultant(P, Q, @z) / py^2;

    poly alpha = reduce(P, py) / (y - @z);    // 2S + K
    poly beta = reduce(Q, py) / (y - @z);
    ideal PAA = py, alpha, beta;
    int dimPAA = vdim(std(PAA));
 
    setring src;
    poly @cuspedge = imap(divdifring, py);    // S
    ideal P3 = @cuspedge, diff(@cuspedge, y);
    int dimP3 = vdim(std(P3));
 
    poly @dpoints = imap(divdifring, tau);    // 2S + K + W
    ideal PT = @cuspedge, @dpoints;
    int dimPT = vdim(std(PT));

    export(@cuspedge, @dpoints);
    return(dimP3,                             // S
           dimPAA - 2 * dimP3,                // K
           dimPT - dimPAA,                    // W
           milnor(@cuspedge),                 // C
           milnor(@dpoints));                 // D
}

//-----------------------------------------------------------------------------
static proc isfrontal(map f)
{
    baseringlocal();
    option(noredefine);

    int minor_size = min(nvars(basering), nvars(preimage(f)));
    matrix df = jacob(ideal(f));
    ideal Jf = std(minor(df, minor_size));

    // the size of the zero ideal is 0
    if (size(Jf) != 1) { ERROR (nameof(f) + "not frontal!"); }
}

//-----------------------------------------------------------------------------
static proc fcodim_curve(list f)
{
	baseringlocal();
	option(noredefine);

	
}
