///////////////////////////////////////////////////////////////////////////////
version="$Id: frontalsurf.lib  2022-17-03 $";
category="Singularities";
info="
LIBRARY: frontals.lib       Compute geometric invariants of a corank 1 frontal
                            surface

AUTHORS: C. Munoz-Cabello,  chmuca@alumni.uv.es

PROCEDURES:
    fcodim(f);           frontal codimension of a plane curve
    invariants(f);       geometric frontal invariants
    wfinvariants(g, z);  geometric invariants of the discriminant

REFERENCES:
    [dJP] de Jong, T., Pfister, G. (2000) Local analytic geometry
    [GLS] Greuel, G.-M., Lossen, C., Shustin, E. (2007) Introduction to
       singularities and deformations
    [Ish] Ishikawa, G. (2020) Recognition problem of frontal singularities
    [MMR] Marar, W.L., Montaldi, J.A. and Ruas, M.A.S. (1999) Multiplicities of
        zero-schemes in quasihomogeneous corank-1 singularities
    [MNB] Mond, D., Nuno-Ballesteros, J.J. (2020) Singularities of Mappings
    [NB]  Nuno-Ballesteros, J.J. (2015) Unfolding plane curves with cusps and
        nodes
";

LIB "general.lib";      // product
LIB "hnoether.lib";     // delta invariant
LIB "homolog.lib";		// fitting
LIB "presmatrix.lib";   // presmatrix
LIB "ring.lib";         // ord_test
LIB "sing.lib";         // tjurina

//-----------------------------------------------------------------------------
proc fcodim(poly f)
"USAGE:   fcodim(f);  f = poly
RETURN:   frontal codimension of a plane curve
REMARK:   This version of fcodim is only beta. Please send bugs and
          comments to: <https://github.com/cuspidalcoffee/Singular>
          Known to work on Singular version 4.2.0.
EXAMPLE:  example fcodim; shows an example"
{
    baseringlocal();  // local ring required for mult

    if (nvars(basering) != 2)
    {
    	ERROR("this procedure is only defined for plane curves!");
    }

	// [dJP], II.2.30(5) or [MNB], D.3. Exercise 6
    // [GLS], II.2.30(5)
   	return(tjurina(f) - delta(f) - mult(f) + 1);
}
example
{
    "EXAMPLE";
    echo = 2;

    ring source = 0, (x, y), ds;
    
    // E_8 singularity from Bruce and Gaffney (1982)
    poly f = x5 + y3;
    fcodim(f);
}
=======


>>>>>>> 5dd17ee (commitment)
//-----------------------------------------------------------------------------
proc invariants(map f)
"USAGE:   invariants(f);  f = map
COMPUTE:  invariants of a corank 1 frontal surface, using the formulas from
          C. Munoz-Cabello, J.J. Nuno-Ballesteros and R. Oset-Sinha's "\"\
RETURN:   * number of swallowtails (@S), cusp-folds (@K), triple points (@T)
            and folded Whitney umbrellas (@W) in the disentanglement of f
          * cuspidal edge (@cuspedge) and double point (@dpoints) curves,
            along with their Milnor numbers
          * frontal Milnor number
REMARK:   This version of invariants is only beta. Please send bugs and
          comments to: <https://github.com/cuspidalcoffee/Singular>
          Known to work on Singular version 4.2.0.
NOTE:     objects with @ sign are exported to global scope
EXAMPLE:  example invariants; shows an example"
{
    string br_name = nameof(basering);  // we need this for presmatrix
    baseringlocal();
    checkvars(2);
    option(noredefine);                 // hide messages such as "redefining"

     // obtain information about f
    list finfo = c1fsurf(f);

    int @S, @K, @W, @C, @D = dp_scheme(finfo[2..4]);

    // image triple point space
    map @f = preimage(f), finfo[1..3];
    ideal @I = 0;
    export(@f, @I);                              // we need this for presmatrix

    "";
    "// Computing triple point space...";
    presmatrix(@f, @I);
    setring RTPr;
    int @T = vdim(std(fitting(PM, 2))) - @S - @K;

    execute("setring " + string(br_name));
    int @mufC = 2 * @S + @muC;
    number @mufD = @K + @T + 1/2 * (@muD + 1 - @W - @S);
    number @muf = @mufD + @T + 1 - @S - @W;

    "";
    "Isolated frontal singularities:";
    " * Swallowtails:              @S = " + string(@S);
    " * Cusp-folds:                @K = " + string(@K);
    " * Triple points:             @T = " + string(@T);
    " * Folded Whitney umbrellas:  @W = " + string(@W);
    export(@S, @K, @T, @W);

    "";
    "Branch of cuspidal edges:";
    " * @cuspedge = " + string(@cuspedge);
    " * Milnor number (source):   @muC = " + string(@muC);
    " *               (target):  @mufC = " + string(@mufC);
    "";
    export(@muC, @mufC);

    "Branch of transversal double points:";
    " * @dpoints = " + string(@dpoints);
    " * Milnor number (source):   @muD = " + string(@muD);
    " *               (target):  @mufD = " + string(@mufD);
    "";
    export(@muD, @mufD);

    "Frontal Milnor number:       @muf = " + string(@muf);
    "";
    export(@muf);
}
example
{
    "EXAMPLE";
    echo = 2;

    ring target = 0, (x, y, z), ds;
    ring source = 0, (x, y), ds;
    export(source, target);  // only needed for this example!

    // 5_3 singularity from Marar and Tari (1995)
    map f = target, x, 5y4 + 3xy2, 4y5 + 2xy3;
    invariants(f);
}

//-----------------------------------------------------------------------------
proc wfinvariants(poly g, poly z)
"USAGE:   wfinvariants(g, z);  g, z=poly
COMPUTE:  invariants in the discriminant of G(x, y, z)=(x, y, g(x, y, z)),
          using the formulas from W.L. Marar, J.A. Montaldi and M.A.S. Ruas's
          "\Multiplicities of zero-schemes in quasihomogeneous corank-1
          singularities"\
RETURN:   number of swallowtails (@S), cusp-folds (@K) and triple points (@T)
          in the discriminant of G.
REMARK:   * g must be weighted homogeneous
          * This version of wfinvariants is only beta. Please send bugs and
          comments to: <https://github.com/cuspidalcoffee/Singular>
          Known to work on Singular version 4.2.0.
NOTE:     objects with @ sign are exported to global scope
EXAMPLE:  example wfinvariants; shows an example"
{
    baseringlocal();
    checkvars(3);
    option(noredefine);    // hide messages such as "redefining"

    intvec w = wdeg(g);    // find the weights and weighted degree of g
    int leadvar = rvar(z);	// find which variable was declared

    if(rvar(z) == 0) { ERROR("variable not in base ring"); }

    // product from the formula
    intvec prod = w[4] div w[leadvar] * (1, 1, 1) - (1, 2, 3);

    /* Singular does not like to use the `/` sign for integer division, so we
     * need to use `div` instead.
     * See https://www.singular.uni-kl.de/Manual/4-0-3/sing_466.htm */

    int @S = w[leadvar]^3 * product(prod) div product(w, 1..3);
    int @K = @S * (w[4] - 4 * w[leadvar]) div w[leadvar];
    int @T = @K * (w[4] - 5 * w[leadvar]) div (6 * w[leadvar]);

    "";
    " * Swallowtails:               @S = " + string(@S);
    " * Cusp-folds:                 @K = " + string(@K);
    " * Triple points:              @T = " + string(@T);
    "";
    " * Target triple point space:       " + string(@S + @K + @T);
    "";
    export(@S, @K, @T);
}
example
{
    "EXAMPLE";
    echo = 2;

    ring r = 0, (x, y, z), ds;

    // 5_3 singularity from Marar and Tari (1995)
    wfinvariants(z5 + xz + yz3, z);
}

//-----------------------------------------------------------------------------
static proc baseringlocal()
{
    option(noredefine);  // hide messages such as "redefining"

    if (ord_test(basering) != -1) { ERROR("no local order ring"); }
}

//-----------------------------------------------------------------------------
static proc checkvars(int n)
{
    option(noredefine);  // hide messages such as "redefining"

    if (nvars(basering) != n)
    {
        ERROR("ring " + nameof(basering) + " must have " + string(n) +
        " variables");
    }
}

//-----------------------------------------------------------------------------
static proc c1fsurf (map f)
{
    /* Given a frontal f[x,y] = [x, p[x,y], q[x,y]], either p_y | q_y or
     * q_y | p_y.
     * Assuming q_y = l * p_y, the singular set S of the Nash lifting is given
     * by the zero locus of p_y and lambda_y.
     * This procedure assumes f is given as above to find x, y, gcd(p_y, q_y)
     * and the codimension of S. */

    isfrontal(f);
    string source_name = nameof(basering);
    string target_name = nameof(preimage(f));

    proc find_y (map f)
    {
        if (f[1] == var(1)) { return(var(1), var(2)); }
        if (f[1] == var(2)) { return(var(2), var(1)); }

        "// ** please introduce a map in the form";
        "// **   map f = " + target_name + ", var, p, q";
        "// ** where var is a variable in " + source_name +
        " and p, q are polynomials";
    
        ERROR("map not set to prenormal form");
    }

    list xy = find_y(f);          // (x,y)
    poly f2y = diff(f[2], xy[2]);
    poly f3y = diff(f[3], xy[2]);

    // return x, p, q, y, codim(Sigma) (in this order)
    if (reduce(f3y, f2y) == 0)
    {
        poly ly = diff(f3y / f2y, y);
        return(xy[1], f[2], f[3], xy[2]);
    }
    else
    {
        poly ly = diff(f2y / f3y, y);
        return(xy[1], f[3], f[2], xy[2]);
    }
}

//-----------------------------------------------------------------------------
static proc dp_scheme(poly p, poly q, poly y)
{
    // add an auxiliar variable for divided differences
    ring src = basering;
    int charsrc = ringlist(src)[1];
    ring aux = charsrc, @z, ds;
    def divdifring = src + aux;     // divided differences ring
    setring divdifring;

    poly p = imap(src, p);
    poly q = imap(src, q);
    poly y = imap(src, y);

    "// Computing double point scheme...";
    poly P = (p - subst(p, y, @z)) / (y - @z);
    poly Q = (q - subst(q, y, @z)) / (y - @z);
    poly py = diff(p, y);
    poly tau = resultant(P, Q, @z) / py^2;

    poly alpha = reduce(P, py) / (y - @z);    // 2S + K
    poly beta = reduce(Q, py) / (y - @z);
    ideal PAA = py, alpha, beta;
    int dimPAA = vdim(std(PAA));
 
    setring src;
    poly @cuspedge = imap(divdifring, py);    // S
    ideal P3 = @cuspedge, diff(@cuspedge, y);
    int dimP3 = vdim(std(P3));
 
    poly @dpoints = imap(divdifring, tau);    // 2S + K + W
    ideal PT = @cuspedge, @dpoints;
    int dimPT = vdim(std(PT));

    export(@cuspedge, @dpoints);
    return(dimP3,                             // S
           dimPAA - 2 * dimP3,                // K
           dimPT - dimPAA,                    // W
           milnor(@cuspedge),                 // C
           milnor(@dpoints));                 // D
}

//-----------------------------------------------------------------------------
static proc isfrontal(map f)
{
    baseringlocal();
    option(noredefine);

    int minor_size = min(nvars(basering), nvars(preimage(f)));
    matrix df = jacob(ideal(f));
    ideal Jf = std(minor(df, minor_size));

    // the size of the zero ideal is 0
    if (size(Jf) != 1) { ERROR (nameof(f) + "not frontal!"); }
}

//-----------------------------------------------------------------------------
static proc wdeg(poly g)
{
    /* Given a quasihomogeneous polynomial g, find d such that
     *
     *   g(var(1)^w[1], ..., var(n)^w[n])
     *
     * is homogeneous of degree d, where w[1]..w[n] are the weights of g. */

    intvec w = qhweight(g);

    if (w == 0)
    {
     "// ** this procedure only works for weighted homogeneous polynomials";
     ERROR(nameof(g) + "not weighted homogeneous");
    }

    for (int i = 1; i <= size(w); i++) { g = subst(g, var(i), var(i)^w[i]); }
    return(w, deg(g));
}
