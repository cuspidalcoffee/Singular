///////////////////////////////////////////////////////////////////////////////
version="$Id: presmatrix.lib  2013-12-03 $";
category="Singularity Theory, Commutative Algebra";
info="
LIBRARY:  presmatrix.lib          Compute presentation matrix

AUTHORS:  Marcelo Escudeiro Hernandes,     mehernandes@uem.br
          Aldicio Jose Miranda,            aldicio@famat.ufu.br
          C. Munoz-Cabello,                chmuca@alumni.uv.es
          Guillermo Penafort-Sanchis,      guillermo.penafort@uv.es
  
PROCEDURES:
  presmatrix(Pullf, ISource);   compute presentation matrix
 
AUXILIARY PROCEDURES:
  Sols(nJ);          return solutions of linear system of parameters
  Row(rh,D,A,h);     compute rh^th line of the presentation matrix
  PolyGen(d);        create polynomial with coefs = 1 and degree d
 ";

 LIB "matrix.lib";
 LIB "rootsur.lib";
 LIB "ring.lib";
 LIB "homolog.lib";
 
//-------------------------------------------------------------------------------------------------
proc presmatrix(map Pullf, ideal ISource)
{
    option(noredefine);
 
    if (ord_test(basering) != -1) {
        print("//No local order ring! Get generators using local order");
    }

    ring RS = basering;
    int l = nvars(RS);

    ring RT = preimage(Pullf);
    int n = nvars(preimage(Pullf)) - 1;
    int n2 = size(IPullf);

    setring RS;
    ideal IPullf = ideal(Pullf);

    if (n+1 != n2) {
        ERROR("Target dimension must be equal the number of entries of given map!");
    }

    execute("string Tvars=varstr("+RTName+")"); //name of vars in target 
    ideal IPullf1 = IPullf[1..n], ISource;      //ideal generated by I and the first n-1 entries of f
    ideal KB = kbase(std(IPullf1));
    int K = size(KB);

    if(K == 0) {
        ERROR("The number of generators must be greater than zero. Verify input!");
    } 

    matrix Gen[1][K];

    for (int r = 1; r <= K; r++)
        { Gen[1, r] = KB[K - r + 1]; }
    
    ring RG = 0, G(1..K), ds;
    matrix M[K][K];
    matrix Pres = diag(Y, K);
    
    map Pf = RT, IPullf;
    int row_done;
    
    for(r = 1; r <= K; r++) {
        int d = 1;
        row_done = 0;
        
        while(!done) {
            setring RT;
            matrix Pols = PolyGen(d);
            int np = size(Pols[1, 1]) + (K - 1) * size(Pols[1, 2]) - 1;
            poly D = Pols[1,1];
            poly A = Pols[1,2];

            // add parameters to source and target
            ring RTP1 = (0, a(1..np)), (X(1..n), Y), ds;
            
            poly D = fetch(RT, D);
            poly A = fetch(RT, A);
            
            list ML = Row(rh, D, A, K);
            matrix M = ML[1];
            list ParList = ML[2];
            
            map mM = RG, M;
            
            ring RSP1 = (0, a(1..np)), x(1..l), dp;
            ideal IPf = fetch(RS, IPullf);
            map Pf = RTP1, IPullf;
            ideal I = std(fetch(RS, ISource)); 

            Gen = fetch(RS, Gen);
            poly p = (Pf(mM)[1]) * Gen[1, 1];
            
            // compute generic polynomial as M * Gen
            for(int c = 2; c <= K; c++)
                { p = p + Pf(mM)[c] * Gen[1, c]; }
            
            //in the source. Next step is to reduce modulo ideal I.
            p = reduce(p,I);

            ideal J; 
            poly u = 1;
            
            for(c = 1; c <= l; c++) {
                u=x(v)*u; //required for coef
            }
            
            matrix C = coef(p,u);
            J = ideal(submat(C, 2, 1..ncols(C)));
            
            int sj = size(J);

            ring RP = 0, (a(1..np)), dp; //ring of parameters
            ideal J = imap(RSP1, J);
            list L = Sols(J);
            
            // if the linear system of param. has no solution, then the degree increases
            if(L[1] == 0)
                { d++; }
            else {
                done = 1;
                setring RT;
                list L = imap(RP,L);   
                list ParList = imap(RTP1, ParList);
                int szS = size(L[2]);
                int pr;
                
                // replace the parameters by respective solutions
                for(c = 1; c <= szS; c++) {
                    pr=L[2][i][1];
                    Pres[rh, ParList[pr][2]] = Pres[rh, ParList[pr][2]] + L[2][i][2] * ParList[pr][1];
                }
            }
        }
    }
    
    //ring to access the presentation matrix
    ring RTPr = 0, Tvars, ds;
    // execute("ring RTPr = 0, ("+Tvars+"),ds");
    
    matrix PM[K][K] = fetch(RT, Pres);
    
    "";
    "//     PM";
    "//R^h ----> R^h ----> Ox ----> 0;  h = " + print(K) + ", R = " + nameof(RT));
    "";
    
    print(PM);
    exportto(Top,RTPr);
    exportto(Top,PM);
    
    "";
    "//To access the presentation matrix PM, type:  setring RTPr; PM; ";
}
//---------------------------------------proc Sols return solutions of linear system of parameters-----------

proc Sols(ideal nJ)
{ 
    list L;
    nJ = std(nJ);

    if(!reduce(1, nJ)) {
        L = 0, list(); // check if this works!!
    }
    else {
        L = 1, list();
        poly LM, Su;
        number LC;
        int s = size(nJ);
        int pos = 1;
        int i = 1;
        
        while(L[1] && i <= s) {
            LC = leadcoef(nJ[i]);
        
            if(LC) {
                LM = leadmonom(nJ[i]);
                Su = -nJ[i] / LC + LM;

                for(int j = i+1; j<=s; j++)
                    { nJ[j] = subst(nJ[j], LM, Su); }
            }
            
        i++;
        }
        
        for(i = s; i >= 1; i--) {
            if(nj[i]) {
			    LM = leadmonom(nJ[i]);

			    while(!univariate(nJ[i])) {
			    	LM = leadmonom(nJ[i]);
					nJ = subst(nJ, LM, 0);
				}

			    LM = leadmonom(nJ[i]);
			    Su= -nJ[i] / leadcoef(nJ[i]) + LM;
			    L[2][pos] = list(univariate(nJ[i]), Su);
			    
			    pos++;
				nJ = subst(nJ, LM, Su);
		}
	}
	      } // ???
    
	return(L);
}
	     
	
//--------------------------------------------------------------------------------------------------
static proc Row(int rh, poly D, poly A, int h)
{
    /*******************************
    rh = rh line;
    D diagonal polinonimal
    A= non-diagonal polinomial
    h = order of presentation matrix
    ********************************/
    
    matrix M[1][h];
    D = D - Y;
    int sD = size(D);
    list ParList;

    int c = 1;

    // left to the main diagonal
    for(int j = 1; j < rh; j++) {   
        for(int i = 1; i <= size(A); i++) {                
            M[1, j] = A[i] * par(c) + M[1, j];
            ParList[c] = list(A[i], j);
            c++;
        }
    } 

    // along the main diagonal
    for(i = 1; i <= size(D); i++) {
        M[1, rh] = D[i] * par(c) + M[1, rh];
        ParList[c]=list(D[i],rh);
        c++;
    } 

    //the coefficient associated to Y is 1
    M[1,rh] = M[1,rh] + Y;

    // right to the main diagonal
    for(j = rh + 1; j <= h; j++) {
        for(i = 1; i <= size(A); i++) {
            M[1, j] = A[i] * par(c) + M[1, j];
            ParList[c] = list(A[i], j);
            c++;
        }
    }
    } // ???

  list L = M, ParList; // this SHOULD work but we shoudl test it anyhow
  return(L);
}

//------------------------Create polynomial with coefs = 1 and degree d---------------------------------
static proc PolyGen(int d)
{
    poly D = sparsepoly(0, d, 0, 1);
    poly PY;

    for (int i = 1; i <= d; i++)
        { PY = PY + Y ^ i; }
    
    poly A = D - PY;
    matrix Pols[1][2] = D, A;

    return(Pols);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////
