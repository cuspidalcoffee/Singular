///////////////////////////////////////////////////////////////////////////////
version="$Id: frontalsurf.lib  2022-25-06 $";
category="Singularity Theory, Algebraic Geometry";
info="
LIBRARY: frontals.lib         Compute topological invariants of corank 1
                              frontal hypersurfaces
                              
AUTHORS: C. Munoz-Cabello,    chmuca@alumni.uv.es

PROCEDURES:
    fcodim(f);             frontal codimension
    fmilnor(f);            frontal Milnor number
    gernotmal(f);          compute the normal line
    invariants(f);         compute stable frontal zero-schemes
    IsFrontal(f);          check if input is frontal
    qi(f);				   compute QI
    wfinvariants(g, y);    compute geometric invariants of the discriminant

REFERENCES:
    [1] Ishikawa, G. (2020) Recognition problem of frontal singularities
    [2] Marar, W.L., Montaldi, J.A. and Ruas, M.A.S. (1999) Multiplicities of
        zero-schemes in quasihomogeneous corank-1 singularities
    [3] Nuno-Ballesteros, J.J. (2015) Unfolding plane curves with cusps and nodes
    [4] https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process
        (Accessed: 2022-06-25)
";

LIB "general.lib";       // product
LIB "presmatrix.lib";    // presmatrix
LIB "ring.lib";          // ord_test
LIB "sing.lib";          // milnor

//-----------------------------------------------------------------------------
proc frontalise(poly p, q, y)
{
    /* Given a corank 1 frontal map in the form
    /*
    /*   map f = R, x, p(x,y), q(x,y)
    /*
    /* f is a frontal if and and only if diff(p, y) divides diff(q, y)
    /* or vice versa.
    /* If we assume the former and set
    /*
    /*    poly p = px[2] * y^2 + px[3] * y^3 + ...
    /*    poly q = qx[2] * y^2 + qx[3] * y^3 + ...
    /*
    /* then diff(p, y) divides diff(q, y) if and only if there are functions
    /* u[1]..u[k-1] such that
    /*
    /*    qx[k] = px[k] * u[1] + px[k-1] * u[2] + ...
    /*                     ... + p[3] * u[k-2] + p[2] * u[k-1]                 */

    // we assume diff(p, y) divides diff(q, y)
    if (vardeg(p, y) > vardeg(q, y)) { return frontalise(q, p, y); }

    // construct u such that diff(q, y) = mu * deg(p, y)
    int degu = vardeg(q, y) - vardeg(p, y);

    ring src = basering;
    ring aux = char(basering), X(1..degu + 1), ds;
    def extsrc = src + aux;

    poly py = imap (src, diff(p, y));
    poly qy = imap (src, diff(q, y));
    poly u = X[degu + 1];

    /* The formula above for qx is tied to two constraints:
    /* - px can only go as high as degp
    /* - u can only go as high as degu + 1 */

    // coeffs(qy,y)
    // coeffs(py,y)

    // we get the equations we need to remove by 
    poly k = qy - mu * py;

    "// auxiliary variables:";
    "//   X[1] .. X[" + string(degmu) "]";
    "// frontalisation equations:";
    "//   " + string(subst(k, y, 0)) + " = 0");
 
    for (i = degqy; i => 0; i--)
    {
         k = diff(k, y);
         "//   " + string(subst(k, y, 0)) + "= 0";
    }
}

//-----------------------------------------------------------------------------
proc getnormal (map f)
{
    /* Use the Gram-Schmidt process to find the orthogonal complement of the
    /* tangent hypersurface to f.
    /* Adapted from [4]                                                      */

    IsFrontal(f);
    
    list U = diff(f, var(1));

	int n = size(preimage(f));

    for (int i = 2; i <= n; i++)
    {
        U[i] = diff(f, var(i));

        for (int j = 1; j < i; j++)
        { U[i] = U[i] - innerproduct(U[j], U[i]) * U[j]; }

        U[i] = U[i] / innerproduct(U[i], U[i]);
    }

    return (U[n]);
}

//-----------------------------------------------------------------------------
proc invariants(map f)
{
    // store name of basering to use presmatrix
    string br_name = nameof(basering);

    // checking for exceptions
    baseringlocal();
    checkvars(2);
    
    option(noredefine);
    list fdata = c1fsurf(f);

    // computations related to the double point scheme
    int @S, @K, @W, @muC, @muD = DPSpace(fdata[2..4]);

    // computations related to target triple point space
    // (export to use presmatrix)
    map @f = preimage(f), fdata[1..3];  
    ideal @I = 0;
    export(@f, @I);

    presmatrix(@f, @I);
    setring RTPr;
    int @T = vdim(std(fitting(PM, 2))) - @S - @K;

    // frontal marar-mond equations and frontal milnor number
    execute("setring " + string(br_name));
    int @mufC = 2 * @S + @muC;
    number @mufD = @K + @T + 1/2 * (@muD + 1 - @W - @S);
    number @muf = 1/2 * (@muD - 1 + @S + @W) - @K - 2 * @T;

    export(@S, @K, @T, @W, @muC, @mufC, @muD, @mufD, @muf);

    "";
    "// Isolated frontal singularities:";
    "//   Swallowtails:               @S = " + string(@S);
    "//   Cusp-folds:                 @K = " + string(@K);
    "//   Triple points:              @T = " + string(@T);
    "//   Folded Whitney umbrellas:   @W = " + string(@W);
    "";
    "// Branch of cuspidal edges:";
    "//   @cuspedge = " + string(@cuspedge);
    "//   Milnor number (source):     @muC = " + string(@muC);
    "//                 (target):    @mufC = " + string(@mufC);
    "";
    "// Branch of transversal double points:";
    "//   @dpoints = " + string(@dpoints);
    "//   Milnor number (source):     @muD = " + string(@muD);
    "//                 (target):    @mufD = " + string(@mufD);
    "";
    "// Frontal Milnor number:        @muf = " + string(@muf);
    "";
    "// Access these variables from global scope by typing their varnames!";
}

//-----------------------------------------------------------------------------
proc IsFrontal(map f, list #)
{
    /* Arguments for `#`:
    /* (no argument): throw an exception if the map is not frontal
    /* r:             report whether the map is frontal                      */

    ideal jf = minor(ideal(jacob(f)), nvars(basering));    // see [2]

    if (nvars(preimage(f)) != nvars(basering) + 1)
    { ERROR(nameof(f) + " not a parametric hypersurface"); }

    if (#[1] == "r")
    {
        if (size(std(jf)) > 1) {return(0);}    // not frontal
        return(1);                             // frontal
    }

    if (size(std(jf)) > 1) { ERROR("not a frontal map"); }
}

//-----------------------------------------------------------------------------
proc Qi (map f)
{
    IsFrontal(f);

 
    for (i=1; i <= nvars(basering); i++)
    {
        if (var(i) != t)
        { I = I, diff(f[2], var(i)) - diff(f[1], var(i)) * mu; }
    }

    return reduce(I,f);
}

//-----------------------------------------------------------------------------
proc wfinvariants(poly g, poly z)
{
    /* Let G(x,y,z) = (x, y, g(x,y,z)) be A-finite and weighted homogeneous.
    /* If g has weights w and degree d,
    /*
    /*        (d - w[3]) (d - 2 w[3]) (d - 3 w[3])
    /*   S = --------------------------------------;
    /*                  w[1] w[2] w[3]
    /*
    /*   K = S (d - 4 w[3]);  T = 1/6 K (d - 5 w[3])
    /*
    /* where S, K, T are the numbers of swallowtails A_3, cusp-folds A_1 A_2
    /* and triple points A_1^3 on the discriminant of G.                     */

    int leadvar, prod, @S, @K, @T;
    intvec w;

    baseringlocal();
    checkvars(3);
    option(noredefine);

    w = wdeg(g);            // find the weights and weighted degree of g
    leadvar = rvar(z);      // find which variable was declared

    if(rvar(z) == 0) { ERROR("variable not in base ring"); }

    // product from the formula
    prod = w[4] div w[leadvar] * (1, 1, 1) - (1, 2, 3);

    /* Singular does not like to use the `/` sign for integer division, so we
    /* need to use `div` instead.                                            */

    @S = w[leadvar]^3 * product(prod) div product(w, 1..3);
    @K = @S * (w[4] - 4 * w[leadvar]) div w[leadvar];
    @T = @K * (w[4] - 5 * w[leadvar]) div (6 * w[leadvar]);

    export(@S, @K, @T);

    "";
    "// Swallowtails:               @S = " + string(@S);
    "// Cusp-folds:                 @K = " + string(@K);
    "// Triple points:              @T = " + string(@T);
    "";
    "// Access these variables from global scope by typing their varnames!";
}

//////////////////////  STATIC PROCEDURES  ////////////////////////////////////

static proc baseringlocal()
{
    option(noredefine);        // hide messages such as "redefining"

    if (ord_test(basering) != -1)
    { ERROR("no local order ring"); }
}

//-----------------------------------------------------------------------------
static proc corank (map f)
{
    matrix jf = jacob(ideal(f));

    for (int i = 1; i <= nvars(basering); i++) { jf = subst(jf, var(i), 0); }

    return nvars(basering) - rank(jf);
}

//-----------------------------------------------------------------------------
static proc checkvars(int n)
{
 option(noredefine);        // hide messages such as "redefining"

 if (nvars(basering) != n)
 {
  ERROR("ring " + nameof(basering) + " must
   have " + string(n) + " variables");
 }
}

//-----------------------------------------------------------------------------
static proc prenormal (map f)
{
   /* Given a corank 1 frontal f(x,y)=(x, p(x, y), q(x, y)), we shall say that
   /* f is in prenormal form if diff(p, y) divides diff(q, y).
   /* This procedure sets f to prenormal form.                               */

    IsFrontal(f, "w");

    // what is a simple, efficient way to find the x??
    
    
    
    map prenormal = preimage(f), immpart, p, q;

    return (prenormal);
}

//-----------------------------------------------------------------------------
static proc DPSpace(poly p, poly q, poly y)
{
    // add an auxiliar variable for divided differences
    ring aux = ringlist(src)[1], @z, ds;
    def divdifring = src + aux;
    setring divdifring;

    poly p = imap(src, p);
    poly q = imap(src, q);
    poly y = imap(src, y);

    "// Computing double point scheme...";

    // compute the double point scheme via divided differences
    poly P = (p - subst(p, y, @z)) / (y - @z);
    poly Q = (q - subst(q, y, @z)) / (y - @z);
    poly py = diff(p, y);
    poly tau = resultant(P, Q, @z) / py^2;

    poly alpha = reduce(P, py) / (y - @z);
    poly beta = reduce(Q, py) / (y - @z);
    int PAA = vdim(std(py, alpha, beta));

    setring src;
    poly @cuspedge = imap(divdifring, py);
    int P3 = vdim(std(@cuspedge, diff(@cuspedge, y)));

    poly @dpoints = imap(divdifring, tau);
    int PT = vdim(std(@cuspedge, @dpoints));

    export(@cuspedge, @dpoints);

     // S, K, W, mu(C,0), mu(D,0)
    return(P3, PAA - 2 * P3, PT - PAA, milnor(@cuspedge), milnor(@dpoints));
}

//-----------------------------------------------------------------------------
static proc innerproduct(ideal u, v)
{
    // inner product of two vector fields encoded as ideals

    if (size(u) != size(v))
    { ERROR("incompatible lengths"); }

    poly product;

    for (int i = 1; i <= length(u); i++)
    { product = product + u[i]*v[i]; }

    return (product);
}

//-----------------------------------------------------------------------------
static proc NoParamWarning(string name, list #)
{
    if(size(#) == 0)
    {
        "// this procedure requires a frontal stable unfolding to work correctly";
        print("// if " + name + " is stable, you may ignore this message");
        "";
        print("// (hint) declare unfolding parameters after " + name);
    }
}

//-----------------------------------------------------------------------------
static proc vardeg(poly f, y)
{
    // degree of a polynomial with respect to a given variable

    // make all other variables zero
    for (int i=1; i <= nvars(basering); i++)
     { if (var(i) != y) { f = subst (f, var(i), 0); } }

    return deg(f);
}

//-----------------------------------------------------------------------------
static proc wdeg(poly g)
{
    /* Given a weighted homogeneous polynomial g, find d such that
    /*
    /*    g(var(1)^w[1], ..., var(n)^w[n])
    /*
    /* is a homogeneous polynomial of degree d with weights w.               */

    intvec w = qhweight(g);

    if (w == 0)
    { ERROR(nameof(g) + " not weighted homogeneous!"); }

    // make g homogeneous
    for (int i = 1; i <= size(w); i++)
    { g = subst(g, var(i), var(i)^w[i]); }

    return(w, deg(g));
}

///////////////////////////////////////////////////////////////////////////////
